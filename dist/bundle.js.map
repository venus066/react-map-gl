{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///bundle.js","webpack:///webpack/bootstrap b913cf7a8c808ec4e61a","webpack:///external \"immutable\"","webpack:///./src/index.js","webpack:///external \"mapbox-gl\"","webpack:///external \"react\"","webpack:///./src/utils/diff-styles.js","webpack:///./src/utils/style-utils.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","noop","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_mapboxGl","_mapboxGl2","_immutable","_react","_diffStyles2","_diffStyles3","_styleUtils","_styleUtils2","MapGL","_PureComponent","_this","getPrototypeOf","_queryParams","accessToken","supported","componentDidMount","componentWillReceiveProps","componentDidUpdate","_onViewportChange","bind","mapStyle","Map","isMap","toJS","map","container","_container","style","center","longitude","latitude","zoom","pitch","bearing","interactive","onViewportChange","attributionControl","preserveDrawingBuffer","canvas","getCanvas","outline","onLoad","once","on","_map","_updateMapViewport","_updateQueryParams","newProps","_updateMapStyle","remove","geometry","parameters","queryParams","layers","queryRenderedFeatures","interactiveLayerIds","update","newSource","source","type","oldSource","getSource","id","oldOpts","workerOptions","undefined","maxzoom","geojsonVtOptions","maxZoom","buffer","tolerance","cluster","clusterRadius","superclusterOptions","radius","clusterMaxZoom","setData","data","removeSource","addSource","prevStyle","nextStyle","styleKeysMap","delete","_this2","prevKeysMap","nextKeysMap","prevKeysList","keys","nextKeysList","some","setStyle","_diffStyles","sourcesDiff","layersDiff","updates","node","layer","enter","forEach","_updateSource","exit","exiting","getLayer","removeLayer","addLayer","before","oldProps","oldMapStyle","preventStyleDiffing","_setDiffStyle","getCenter","lat","lng","getZoom","getPitch","getBearing","flyTo","event","_map$getCenter","viewport","_this3","_props","className","createElement","ref","_ref","PureComponent","displayName","defaultProps","diffSources","prevSources","nextSources","prevIds","keySeq","toArray","nextIds","nextSource","equals","push","diffLayers","prevLayers","nextLayers","prevMap","nextMap","index","layerImBehind","reverse","diffStyle","getInteractiveLayerIds","filter"],"mappings":"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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"immutable\"), require(\"mapbox-gl\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"immutable\", \"mapbox-gl\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@urbica/react-map-gl\"] = factory(require(\"immutable\"), require(\"mapbox-gl\"), require(\"react\"));\n\telse\n\t\troot[\"@urbica/react-map-gl\"] = factory(root[\"immutable\"], root[\"mapbox-gl\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"immutable\"), require(\"mapbox-gl\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"immutable\", \"mapbox-gl\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@urbica/react-map-gl\"] = factory(require(\"immutable\"), require(\"mapbox-gl\"), require(\"react\"));\n\telse\n\t\troot[\"@urbica/react-map-gl\"] = factory(root[\"immutable\"], root[\"mapbox-gl\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mapboxGl = __webpack_require__(2);\n\nvar _mapboxGl2 = _interopRequireDefault(_mapboxGl);\n\nvar _immutable = __webpack_require__(0);\n\nvar _react = __webpack_require__(3);\n\nvar _diffStyles2 = __webpack_require__(4);\n\nvar _diffStyles3 = _interopRequireDefault(_diffStyles2);\n\nvar _styleUtils = __webpack_require__(5);\n\nvar _styleUtils2 = _interopRequireDefault(_styleUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction noop() {}\n\n/**\n * Properties\n */\n\nvar MapGL = function (_PureComponent) {\n  _inherits(MapGL, _PureComponent);\n\n  _createClass(MapGL, null, [{\n    key: 'supported',\n    value: function supported() {\n      return _mapboxGl2.default && _mapboxGl2.default.supported();\n    }\n  }]);\n\n  function MapGL(props) {\n    _classCallCheck(this, MapGL);\n\n    var _this = _possibleConstructorReturn(this, (MapGL.__proto__ || Object.getPrototypeOf(MapGL)).call(this, props));\n\n    _this._queryParams = {};\n\n    if (_mapboxGl2.default) {\n      _mapboxGl2.default.accessToken = props.accessToken;\n    }\n\n    if (!MapGL.supported()) {\n      _this.componentDidMount = noop;\n      _this.componentWillReceiveProps = noop;\n      _this.componentDidUpdate = noop;\n    }\n\n    _this._onViewportChange = _this._onViewportChange.bind(_this);\n    return _this;\n  }\n\n  _createClass(MapGL, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (!_mapboxGl2.default) {\n        return;\n      }\n\n      var mapStyle = _immutable.Map.isMap(this.props.mapStyle) ? this.props.mapStyle.toJS() : this.props.mapStyle;\n\n      var map = new _mapboxGl2.default.Map({\n        container: this._container,\n        style: mapStyle,\n        center: [this.props.longitude, this.props.latitude],\n        zoom: this.props.zoom,\n        pitch: this.props.pitch,\n        bearing: this.props.bearing,\n        interactive: !!this.props.onViewportChange,\n        attributionControl: this.props.attributionControl,\n        preserveDrawingBuffer: this.props.preserveDrawingBuffer\n      });\n\n      // Disable outline style\n      var canvas = map.getCanvas();\n      if (canvas) {\n        canvas.style.outline = 'none';\n      }\n\n      // Attach optional onLoad function\n      if (this.props.onLoad) {\n        map.once('load', this.props.onLoad);\n      }\n\n      map.on('drag', this._onViewportChange);\n      map.on('zoom', this._onViewportChange);\n\n      this._map = map;\n      this._updateMapViewport(this.props);\n      this._updateQueryParams(mapStyle);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(newProps) {\n      if (!_mapboxGl2.default) {\n        return;\n      }\n\n      this._updateMapViewport(newProps);\n      this._updateMapStyle(this.props, newProps);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (!_mapboxGl2.default) {\n        return;\n      }\n\n      if (this._map) {\n        this._map.remove();\n      }\n    }\n\n    /**\n     * Exposes Mapbox GL Map instance.\n     * External apps can access map this way\n     *\n     * @returns {mapboxgl.Map}\n     */\n\n  }, {\n    key: 'getMap',\n    value: function getMap() {\n      return this._map;\n    }\n\n    /** Uses Mapbox's\n      * queryRenderedFeatures API to find features at point or in a bounding box.\n      * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n      * To query only some of the layers, set the `interactive` property in the\n      * layer style to `true`.\n      * @param {[Number, Number]|[[Number, Number], [Number, Number]]} geometry -\n      *   Point or an array of two points defining the bounding box\n      * @param {Object} parameters - query options\n      */\n\n  }, {\n    key: 'queryRenderedFeatures',\n    value: function queryRenderedFeatures(geometry, parameters) {\n      var queryParams = parameters || this._queryParams;\n      if (queryParams.layers && queryParams.layers.length === 0) {\n        return [];\n      }\n      return this._map.queryRenderedFeatures(geometry, queryParams);\n    }\n\n    /**\n     * Hover and click only query layers whose interactive property is true\n     *\n     * @private\n     * @param {MapStyle} mapStyle\n     */\n\n  }, {\n    key: '_updateQueryParams',\n    value: function _updateQueryParams(mapStyle) {\n      var interactiveLayerIds = (0, _styleUtils2.default)(mapStyle);\n      this._queryParams = { layers: interactiveLayerIds };\n    }\n\n    /**\n     * Update a source in the map style\n     *\n     * @private\n     * @param {SourcesDiffElement} update\n     */\n\n  }, {\n    key: '_updateSource',\n    value: function _updateSource(update) {\n      var map = this._map;\n      var newSource = update.source.toJS();\n      if (newSource.type === 'geojson') {\n        var oldSource = map.getSource(update.id);\n        if (oldSource.type === 'geojson') {\n          // update data if no other GeoJSONSource options were changed\n          var oldOpts = oldSource.workerOptions;\n          if ((newSource.maxzoom === undefined || newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) && (newSource.buffer === undefined || newSource.buffer === oldOpts.geojsonVtOptions.buffer) && (newSource.tolerance === undefined || newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) && (newSource.cluster === undefined || newSource.cluster === oldOpts.cluster) && (newSource.clusterRadius === undefined || newSource.clusterRadius === oldOpts.superclusterOptions.radius) && (newSource.clusterMaxZoom === undefined || newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)) {\n            oldSource.setData(newSource.data);\n            return;\n          }\n        }\n      }\n\n      map.removeSource(update.id);\n      map.addSource(update.id, newSource);\n    }\n\n    /**\n     * Individually update the maps source and layers that have changed if all\n     * other style props haven't changed. This prevents flicking of the map when\n     * styles only change sources or layers.\n     *\n     * @private\n     * @param {MapStyle} prevStyle\n     * @param {MapStyle} nextStyle\n     * @returns {void}\n     */\n\n  }, {\n    key: '_setDiffStyle',\n    value: function _setDiffStyle(prevStyle, nextStyle) {\n      var _this2 = this;\n\n      function styleKeysMap(style) {\n        return style.map(function () {\n          return true;\n        }).delete('layers').delete('sources').toJS();\n      }\n\n      var prevKeysMap = prevStyle && (styleKeysMap(prevStyle) || {});\n      var nextKeysMap = styleKeysMap(nextStyle);\n\n      function propsOtherThanLayersOrSourcesDiffer() {\n        var prevKeysList = Object.keys(prevKeysMap);\n        var nextKeysList = Object.keys(nextKeysMap);\n        if (prevKeysList.length !== nextKeysList.length) {\n          return true;\n        }\n        // `nextStyle` and `prevStyle` should not have the same set of props.\n        if (nextKeysList.some(function (key) {\n          return prevStyle.get(key) !== nextStyle.get(key);\n        }\n        // But the value of one of those props is different.\n        )) {\n          return true;\n        }\n        return false;\n      }\n\n      var map = this._map;\n\n      if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {\n        map.setStyle(nextStyle.toJS());\n        return;\n      }\n\n      var _diffStyles = (0, _diffStyles3.default)(prevStyle, nextStyle),\n          sourcesDiff = _diffStyles.sourcesDiff,\n          layersDiff = _diffStyles.layersDiff;\n\n      // TODO: It's rather difficult to determine style diffing in the presence\n      // of refs. For now, if any style update has a ref, fallback to no diffing.\n      // We can come back to this case if there's a solid usecase.\n\n\n      if (layersDiff.updates.some(function (node) {\n        return node.layer.get('ref');\n      })) {\n        map.setStyle(nextStyle.toJS());\n        return;\n      }\n\n      sourcesDiff.enter.forEach(function (enter) {\n        return map.addSource(enter.id, enter.source.toJS());\n      });\n\n      sourcesDiff.update.forEach(function (update) {\n        return _this2._updateSource(update);\n      });\n\n      sourcesDiff.exit.forEach(function (exit) {\n        return map.removeSource(exit.id);\n      });\n\n      layersDiff.exiting.forEach(function (exit) {\n        if (map.style.getLayer(exit.id)) {\n          map.removeLayer(exit.id);\n        }\n      });\n\n      layersDiff.updates.forEach(function (update) {\n        if (!update.enter) {\n          // This is an old layer that needs to be updated. Remove the old layer\n          // with the same id and add it back again.\n          map.removeLayer(update.id);\n        }\n        map.addLayer(update.layer.toJS(), update.before);\n      });\n    }\n\n    /**\n     * Update Map style from newProps\n     *\n     * @private\n     * @param {Props} oldProps\n     * @param {Props} newProps\n     */\n\n  }, {\n    key: '_updateMapStyle',\n    value: function _updateMapStyle(oldProps, newProps) {\n      var mapStyle = newProps.mapStyle;\n      var oldMapStyle = oldProps.mapStyle;\n      if (mapStyle !== oldMapStyle) {\n        if (_immutable.Map.isMap(mapStyle)) {\n          if (this.props.preventStyleDiffing) {\n            this._map.setStyle(mapStyle.toJS());\n          } else {\n            this._setDiffStyle(oldMapStyle, mapStyle);\n          }\n        } else {\n          this._map.setStyle(mapStyle);\n        }\n        this._updateQueryParams(mapStyle);\n      }\n    }\n\n    /**\n     * Update Map viewport from newProps\n     *\n     * @private\n     * @param {Props} newProps\n     */\n\n  }, {\n    key: '_updateMapViewport',\n    value: function _updateMapViewport(newProps) {\n      var map = this._map;\n      var center = map.getCenter();\n\n      var viewportChanged = newProps.latitude !== center.lat || newProps.longitude !== center.lng || newProps.zoom !== map.getZoom() || newProps.pitch !== map.getPitch() || newProps.bearing !== map.getBearing();\n\n      if (viewportChanged) {\n        map.flyTo({\n          center: [newProps.longitude, newProps.latitude],\n          zoom: newProps.zoom,\n          pitch: newProps.pitch,\n          bearing: newProps.bearing\n        });\n      }\n    }\n\n    /**\n     * fires `onViewportChange` callback when the user interacted with the map.\n     *\n     * @private\n     * @param {(mapboxgl.MapMouseEvent | mapboxgl.MapTouchEvent)} event\n     */\n\n  }, {\n    key: '_onViewportChange',\n    value: function _onViewportChange(event) {\n      var map = event.target;\n\n      var _map$getCenter = map.getCenter(),\n          lng = _map$getCenter.lng,\n          lat = _map$getCenter.lat;\n\n      var zoom = map.getZoom();\n      var pitch = map.getPitch();\n      var bearing = map.getBearing();\n\n      var viewport = {\n        latitude: lat,\n        longitude: lng,\n        zoom: zoom,\n        pitch: pitch,\n        bearing: bearing\n      };\n\n      this.props.onViewportChange(viewport);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          className = _props.className,\n          style = _props.style;\n\n\n      return (0, _react.createElement)('div', {\n        ref: function ref(_ref) {\n          return _this3._container = _ref;\n        },\n        style: style,\n        className: className\n      });\n    }\n  }]);\n\n  return MapGL;\n}(_react.PureComponent);\n\nMapGL.displayName = 'MapGL';\nMapGL.defaultProps = {\n  className: null,\n  mapStyle: 'mapbox://styles/mapbox/light-v8',\n  accessToken: null,\n  preserveDrawingBuffer: false,\n  onViewportChange: null,\n  attributionControl: true,\n  preventStyleDiffing: false,\n  bearing: 0,\n  pitch: 0,\n  onLoad: null\n};\n\nexports.default = MapGL;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffSources = diffSources;\nexports.diffLayers = diffLayers;\nexports.default = diffStyle;\nfunction diffSources(prevStyle, nextStyle) {\n  var prevSources = prevStyle.get('sources');\n  var nextSources = nextStyle.get('sources');\n  var enter = [];\n  var update = [];\n  var exit = [];\n  var prevIds = prevSources.keySeq().toArray();\n  var nextIds = nextSources.keySeq().toArray();\n  prevIds.forEach(function (id) {\n    var nextSource = nextSources.get(id);\n    if (nextSource) {\n      if (!nextSource.equals(prevSources.get(id))) {\n        update.push({ id: id, source: nextSources.get(id) });\n      }\n    } else {\n      exit.push({ id: id, source: prevSources.get(id) });\n    }\n  });\n  nextIds.forEach(function (id) {\n    var prevSource = prevSources.get(id);\n    if (!prevSource) {\n      enter.push({ id: id, source: nextSources.get(id) });\n    }\n  });\n  return { enter: enter, update: update, exit: exit };\n}\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nfunction diffLayers(prevStyle, nextStyle) {\n  var prevLayers = prevStyle.get('layers');\n  var nextLayers = nextStyle.get('layers');\n  var updates = [];\n  var exiting = [];\n  var prevMap = {};\n  var nextMap = {};\n  nextLayers.forEach(function (layer, index) {\n    var id = layer.get('id');\n    var layerImBehind = nextLayers.get(index + 1);\n    nextMap[id] = {\n      layer: layer,\n      id: id,\n      // The `id` of the layer before this one.\n      before: layerImBehind ? layerImBehind.get('id') : null,\n      enter: true\n    };\n  });\n  prevLayers.forEach(function (layer, index) {\n    var id = layer.get('id');\n    var layerImBehind = prevLayers.get(index + 1);\n    prevMap[id] = {\n      layer: layer,\n      id: id,\n      before: layerImBehind ? layerImBehind.get('id') : null\n    };\n    if (nextMap[id]) {\n      // Not a new layer.\n      nextMap[id].enter = false;\n    } else {\n      // This layer is being removed.\n      exiting.push(prevMap[id]);\n    }\n  });\n  nextLayers.reverse().forEach(function (layer) {\n    var id = layer.get('id');\n    if (!prevMap[id] || !prevMap[id].layer.equals(nextMap[id].layer) || prevMap[id].before !== nextMap[id].before) {\n      // This layer is being changed.\n      updates.push(nextMap[id]);\n    }\n  });\n  return { updates: updates, exiting: exiting };\n}\n\nfunction diffStyle(prevStyle, nextStyle) {\n  return {\n    sourcesDiff: diffSources(prevStyle, nextStyle),\n    layersDiff: diffLayers(prevStyle, nextStyle)\n  };\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _immutable = __webpack_require__(0);\n\nfunction getInteractiveLayerIds(mapStyle) {\n  if (mapStyle instanceof _immutable.Map) {\n    var layers = mapStyle.get('layers');\n    if (layers) {\n      return layers.filter(function (l) {\n        return l.get('interactive');\n      }).map(function (l) {\n        return l.get('id');\n      }).toJS();\n    }\n  }\n\n  return [];\n}\n\nexports.default = getInteractiveLayerIds;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b913cf7a8c808ec4e61a","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"immutable\"\n// module id = 0\n// module chunks = 0","/* @flow */\n\nimport mapboxgl from 'mapbox-gl';\nimport { Map } from 'immutable';\nimport { PureComponent, createElement } from 'react';\n\nimport diffStyles from './utils/diff-styles';\nimport getInteractiveLayerIds from './utils/style-utils';\n\nimport type { MapStyle, SourcesDiffElement, Viewport } from './types';\n\nfunction noop() {}\n\n/**\n * Properties\n */\ntype Props = {\n  /** container className */\n  className: string,\n\n  /** container style */\n  style: Object,\n\n  /** Mapbox API access token for mapbox-gl-js. Required when using Mapbox vector tiles/styles. */\n  accessToken: string,\n\n  /** Mapbox WebGL context creation option. Useful when you want to export the canvas as a PNG. */\n  preserveDrawingBuffer: boolean,\n\n  /** Show attribution control or not. */\n  attributionControl: boolean,\n\n  /** The Mapbox style. A string url or a MapboxGL style Immutable.Map object. */\n  mapStyle: MapStyle,\n\n  /** There are known issues with style diffing. As stopgap, add option to prevent style diffing. */\n  preventStyleDiffing: boolean,\n\n  /**\n   * `onViewportChange` callback is fired when the user interacted with the\n   * map. The object passed to the callback contains viewport properties\n   * such as `longitude`, `latitude`, `zoom` etc.\n   */\n  onViewportChange: (viewport: Viewport) => mixed,\n\n  /** The longitude of the center of the map. */\n  longitude: number,\n\n  /** The latitude of the center of the map. */\n  latitude: number,\n\n  /** The tile zoom level of the map. */\n  zoom: number,\n\n  /** Specify the bearing of the viewport */\n  bearing: number,\n\n  /** Specify the pitch of the viewport */\n  pitch: number,\n\n  /** The onLoad callback for the map */\n  onLoad: Function\n};\n\nclass MapGL extends PureComponent<*, Props, *> {\n  props: Props;\n\n  componentDidMount: Function;\n  componentWillReceiveProps: Function;\n  componentDidUpdate: Function;\n\n  _map: mapboxgl.Map;\n  _container: HTMLElement;\n  _queryParams: Object;\n  _onViewportChange: (event: mapboxgl.MapMouseEvent | mapboxgl.MapTouchEvent) => void;\n\n  static supported() {\n    return mapboxgl && mapboxgl.supported();\n  }\n\n  constructor(props: Props) {\n    super(props);\n    this._queryParams = {};\n\n    if (mapboxgl) {\n      mapboxgl.accessToken = props.accessToken;\n    }\n\n    if (!MapGL.supported()) {\n      this.componentDidMount = noop;\n      this.componentWillReceiveProps = noop;\n      this.componentDidUpdate = noop;\n    }\n\n    this._onViewportChange = this._onViewportChange.bind(this);\n  }\n\n  componentDidMount() {\n    if (!mapboxgl) {\n      return;\n    }\n\n    const mapStyle = Map.isMap(this.props.mapStyle)\n      ? this.props.mapStyle.toJS()\n      : this.props.mapStyle;\n\n    const map = new mapboxgl.Map({\n      container: this._container,\n      style: mapStyle,\n      center: [this.props.longitude, this.props.latitude],\n      zoom: this.props.zoom,\n      pitch: this.props.pitch,\n      bearing: this.props.bearing,\n      interactive: !!this.props.onViewportChange,\n      attributionControl: this.props.attributionControl,\n      preserveDrawingBuffer: this.props.preserveDrawingBuffer\n    });\n\n    // Disable outline style\n    const canvas = map.getCanvas();\n    if (canvas) {\n      canvas.style.outline = 'none';\n    }\n\n    // Attach optional onLoad function\n    if (this.props.onLoad) {\n      map.once('load', this.props.onLoad);\n    }\n\n    map.on('drag', this._onViewportChange);\n    map.on('zoom', this._onViewportChange);\n\n    this._map = map;\n    this._updateMapViewport(this.props);\n    this._updateQueryParams(mapStyle);\n  }\n\n  componentWillReceiveProps(newProps: Props) {\n    if (!mapboxgl) {\n      return;\n    }\n\n    this._updateMapViewport(newProps);\n    this._updateMapStyle(this.props, newProps);\n  }\n\n  componentWillUnmount() {\n    if (!mapboxgl) {\n      return;\n    }\n\n    if (this._map) {\n      this._map.remove();\n    }\n  }\n\n  /**\n   * Exposes Mapbox GL Map instance.\n   * External apps can access map this way\n   *\n   * @returns {mapboxgl.Map}\n   */\n  getMap(): mapboxgl.Map {\n    return this._map;\n  }\n\n  /** Uses Mapbox's\n    * queryRenderedFeatures API to find features at point or in a bounding box.\n    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n    * To query only some of the layers, set the `interactive` property in the\n    * layer style to `true`.\n    * @param {[Number, Number]|[[Number, Number], [Number, Number]]} geometry -\n    *   Point or an array of two points defining the bounding box\n    * @param {Object} parameters - query options\n    */\n  queryRenderedFeatures(geometry: mapboxgl.Point | mapboxgl.Point[], parameters: Object) {\n    const queryParams = parameters || this._queryParams;\n    if (queryParams.layers && queryParams.layers.length === 0) {\n      return [];\n    }\n    return this._map.queryRenderedFeatures(geometry, queryParams);\n  }\n\n  /**\n   * Hover and click only query layers whose interactive property is true\n   *\n   * @private\n   * @param {MapStyle} mapStyle\n   */\n  _updateQueryParams(mapStyle: MapStyle): void {\n    const interactiveLayerIds = getInteractiveLayerIds(mapStyle);\n    this._queryParams = { layers: interactiveLayerIds };\n  }\n\n  /**\n   * Update a source in the map style\n   *\n   * @private\n   * @param {SourcesDiffElement} update\n   */\n  _updateSource(update: SourcesDiffElement): void {\n    const map = this._map;\n    const newSource = update.source.toJS();\n    if (newSource.type === 'geojson') {\n      const oldSource = map.getSource(update.id);\n      if (oldSource.type === 'geojson') {\n        // update data if no other GeoJSONSource options were changed\n        const oldOpts = oldSource.workerOptions;\n        if (\n          (newSource.maxzoom === undefined ||\n            newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) &&\n          (newSource.buffer === undefined ||\n            newSource.buffer === oldOpts.geojsonVtOptions.buffer) &&\n          (newSource.tolerance === undefined ||\n            newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) &&\n          (newSource.cluster === undefined ||\n            newSource.cluster === oldOpts.cluster) &&\n          (newSource.clusterRadius === undefined ||\n            newSource.clusterRadius === oldOpts.superclusterOptions.radius) &&\n          (newSource.clusterMaxZoom === undefined ||\n            newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)\n        ) {\n          oldSource.setData(newSource.data);\n          return;\n        }\n      }\n    }\n\n    map.removeSource(update.id);\n    map.addSource(update.id, newSource);\n  }\n\n\n  /**\n   * Individually update the maps source and layers that have changed if all\n   * other style props haven't changed. This prevents flicking of the map when\n   * styles only change sources or layers.\n   *\n   * @private\n   * @param {MapStyle} prevStyle\n   * @param {MapStyle} nextStyle\n   * @returns {void}\n   */\n  _setDiffStyle(prevStyle: MapStyle, nextStyle: MapStyle): void {\n    function styleKeysMap(style: MapStyle) {\n      return style.map(() => true).delete('layers').delete('sources').toJS();\n    }\n\n    const prevKeysMap = prevStyle && (styleKeysMap(prevStyle) || {});\n    const nextKeysMap = styleKeysMap(nextStyle);\n\n    function propsOtherThanLayersOrSourcesDiffer() {\n      const prevKeysList = Object.keys(prevKeysMap);\n      const nextKeysList = Object.keys(nextKeysMap);\n      if (prevKeysList.length !== nextKeysList.length) {\n        return true;\n      }\n      // `nextStyle` and `prevStyle` should not have the same set of props.\n      if (\n        nextKeysList.some(\n          key => prevStyle.get(key) !== nextStyle.get(key)\n          // But the value of one of those props is different.\n        )\n      ) {\n        return true;\n      }\n      return false;\n    }\n\n    const map = this._map;\n\n    if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    const { sourcesDiff, layersDiff } = diffStyles(prevStyle, nextStyle);\n\n    // TODO: It's rather difficult to determine style diffing in the presence\n    // of refs. For now, if any style update has a ref, fallback to no diffing.\n    // We can come back to this case if there's a solid usecase.\n    if (layersDiff.updates.some(node => node.layer.get('ref'))) {\n      map.setStyle(nextStyle.toJS());\n      return;\n    }\n\n    sourcesDiff.enter.forEach(enter =>\n      map.addSource(enter.id, enter.source.toJS())\n    );\n\n    sourcesDiff.update.forEach(update => this._updateSource(update));\n\n    sourcesDiff.exit.forEach(exit => map.removeSource(exit.id));\n\n    layersDiff.exiting.forEach((exit) => {\n      if (map.style.getLayer(exit.id)) {\n        map.removeLayer(exit.id);\n      }\n    });\n\n    layersDiff.updates.forEach((update) => {\n      if (!update.enter) {\n        // This is an old layer that needs to be updated. Remove the old layer\n        // with the same id and add it back again.\n        map.removeLayer(update.id);\n      }\n      map.addLayer(update.layer.toJS(), update.before);\n    });\n  }\n\n  /**\n   * Update Map style from newProps\n   *\n   * @private\n   * @param {Props} oldProps\n   * @param {Props} newProps\n   */\n  _updateMapStyle(oldProps: Props, newProps: Props): void {\n    const mapStyle = newProps.mapStyle;\n    const oldMapStyle = oldProps.mapStyle;\n    if (mapStyle !== oldMapStyle) {\n      if (Map.isMap(mapStyle)) {\n        if (this.props.preventStyleDiffing) {\n          this._map.setStyle(mapStyle.toJS());\n        } else {\n          this._setDiffStyle(oldMapStyle, mapStyle);\n        }\n      } else {\n        this._map.setStyle(mapStyle);\n      }\n      this._updateQueryParams(mapStyle);\n    }\n  }\n\n  /**\n   * Update Map viewport from newProps\n   *\n   * @private\n   * @param {Props} newProps\n   */\n  _updateMapViewport(newProps: Props): void {\n    const map = this._map;\n    const center = map.getCenter();\n\n    const viewportChanged =\n      newProps.latitude !== center.lat ||\n      newProps.longitude !== center.lng ||\n      newProps.zoom !== map.getZoom() ||\n      newProps.pitch !== map.getPitch() ||\n      newProps.bearing !== map.getBearing();\n\n    if (viewportChanged) {\n      map.flyTo({\n        center: [newProps.longitude, newProps.latitude],\n        zoom: newProps.zoom,\n        pitch: newProps.pitch,\n        bearing: newProps.bearing\n      });\n    }\n  }\n\n  /**\n   * fires `onViewportChange` callback when the user interacted with the map.\n   *\n   * @private\n   * @param {(mapboxgl.MapMouseEvent | mapboxgl.MapTouchEvent)} event\n   */\n  _onViewportChange(event: mapboxgl.MapMouseEvent | mapboxgl.MapTouchEvent): void {\n    const map = event.target;\n    const { lng, lat } = map.getCenter();\n    const zoom = map.getZoom();\n    const pitch = map.getPitch();\n    const bearing = map.getBearing();\n\n    const viewport = {\n      latitude: lat,\n      longitude: lng,\n      zoom,\n      pitch,\n      bearing\n    };\n\n    this.props.onViewportChange(viewport);\n  }\n\n  render() {\n    const { className, style } = this.props;\n\n    return createElement('div', {\n      ref: ref => this._container = ref,\n      style,\n      className\n    });\n  }\n}\n\nMapGL.displayName = 'MapGL';\nMapGL.defaultProps = {\n  className: null,\n  mapStyle: 'mapbox://styles/mapbox/light-v8',\n  accessToken: null,\n  preserveDrawingBuffer: false,\n  onViewportChange: null,\n  attributionControl: true,\n  preventStyleDiffing: false,\n  bearing: 0,\n  pitch: 0,\n  onLoad: null\n};\n\nexport default MapGL;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mapbox-gl\"\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 3\n// module chunks = 0","/* @flow */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport type { MapStyle, SourcesDiff, LayersDiff } from '../types';\n\nexport function diffSources(prevStyle: MapStyle, nextStyle: MapStyle): SourcesDiff {\n  const prevSources = prevStyle.get('sources');\n  const nextSources = nextStyle.get('sources');\n  const enter = [];\n  const update = [];\n  const exit = [];\n  const prevIds = prevSources.keySeq().toArray();\n  const nextIds = nextSources.keySeq().toArray();\n  prevIds.forEach((id) => {\n    const nextSource = nextSources.get(id);\n    if (nextSource) {\n      if (!nextSource.equals(prevSources.get(id))) {\n        update.push({ id, source: nextSources.get(id) });\n      }\n    } else {\n      exit.push({ id, source: prevSources.get(id) });\n    }\n  });\n  nextIds.forEach((id) => {\n    const prevSource = prevSources.get(id);\n    if (!prevSource) {\n      enter.push({ id, source: nextSources.get(id) });\n    }\n  });\n  return { enter, update, exit };\n}\n\nexport function diffLayers(prevStyle: MapStyle, nextStyle: MapStyle): LayersDiff {\n  const prevLayers = prevStyle.get('layers');\n  const nextLayers = nextStyle.get('layers');\n  const updates = [];\n  const exiting = [];\n  const prevMap = {};\n  const nextMap = {};\n  nextLayers.forEach((layer, index) => {\n    const id = layer.get('id');\n    const layerImBehind = nextLayers.get(index + 1);\n    nextMap[id] = {\n      layer,\n      id,\n      // The `id` of the layer before this one.\n      before: layerImBehind ? layerImBehind.get('id') : null,\n      enter: true\n    };\n  });\n  prevLayers.forEach((layer, index) => {\n    const id = layer.get('id');\n    const layerImBehind = prevLayers.get(index + 1);\n    prevMap[id] = {\n      layer,\n      id,\n      before: layerImBehind ? layerImBehind.get('id') : null\n    };\n    if (nextMap[id]) {\n      // Not a new layer.\n      nextMap[id].enter = false;\n    } else {\n      // This layer is being removed.\n      exiting.push(prevMap[id]);\n    }\n  });\n  nextLayers.reverse().forEach((layer) => {\n    const id = layer.get('id');\n    if (\n      !prevMap[id] ||\n      !prevMap[id].layer.equals(nextMap[id].layer) ||\n      prevMap[id].before !== nextMap[id].before\n    ) {\n      // This layer is being changed.\n      updates.push(nextMap[id]);\n    }\n  });\n  return { updates, exiting };\n}\n\nexport default function diffStyle(prevStyle: MapStyle, nextStyle: MapStyle) {\n  return {\n    sourcesDiff: diffSources(prevStyle, nextStyle),\n    layersDiff: diffLayers(prevStyle, nextStyle)\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/diff-styles.js","/* @flow */\n\nimport { Map } from 'immutable';\nimport type { MapStyle } from '../types';\n\nfunction getInteractiveLayerIds(mapStyle: MapStyle): Array<String> {\n  if (mapStyle instanceof Map) {\n    const layers = mapStyle.get('layers');\n    if (layers) {\n      return layers\n        .filter(l => l.get('interactive'))\n        .map(l => l.get('id'))\n        .toJS();\n    }\n  }\n\n  return [];\n}\n\nexport default getInteractiveLayerIds;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/style-utils.js"],"sourceRoot":""}